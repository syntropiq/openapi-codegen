import { OpenAPISpec, Schema, GeneratedFile } from '../config/types';

/**
 * Generate TypeScript types from OpenAPI schema definitions
 */
export function generateTypes(spec: OpenAPISpec): GeneratedFile {
  const types: string[] = [];
  
  // Add file header
  types.push('// Generated TypeScript types from OpenAPI specification');
  types.push('// Do not edit this file manually');
  types.push('');

  // Generate types from components/schemas
  if (spec.components?.schemas) {
    for (const [name, schema] of Object.entries(spec.components.schemas)) {
      const typeDefinition = generateTypeFromSchema(name, schema);
      types.push(typeDefinition);
      types.push('');
    }
  }

  // Generate request/response types for each operation
  if (spec.paths) {
    for (const [path, pathItem] of Object.entries(spec.paths)) {
      if (!pathItem) continue;
      
      const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace'];
      
      for (const method of methods) {
        const operation = pathItem[method as keyof typeof pathItem];
        if (!operation) continue;
        
        const operationId = operation.operationId || `${method}${sanitizeName(path)}`;
        
        // Generate request type
        const requestType = generateRequestType(operationId, operation);
        if (requestType) {
          types.push(requestType);
          types.push('');
        }
        
        // Generate response types
        const responseTypes = generateResponseTypes(operationId, operation);
        types.push(...responseTypes);
        types.push('');
      }
    }
  }

  return {
    path: 'types.ts',
    content: types.join('\n'),
    description: 'Generated TypeScript type definitions'
  };
}

function generateTypeFromSchema(name: string, schema: Schema): string {
  const typeName = sanitizeTypeName(name);
  const typeDefinition = convertSchemaToTypeScript(schema);
  
  return `export interface ${typeName} ${typeDefinition}`;
}

function convertSchemaToTypeScript(schema: Schema, depth = 0): string {
  if (depth > 10) return 'any'; // Prevent infinite recursion
  
  if (schema.$ref) {
    return extractRefName(schema.$ref);
  }
  
  if (schema.allOf) {
    const types = schema.allOf.map(s => convertSchemaToTypeScript(s, depth + 1));
    return types.join(' & ');
  }
  
  if (schema.oneOf || schema.anyOf) {
    const types = (schema.oneOf || schema.anyOf)!.map(s => convertSchemaToTypeScript(s, depth + 1));
    return types.join(' | ');
  }
  
  if (schema.enum) {
    return schema.enum.map(val => typeof val === 'string' ? `'${val}'` : String(val)).join(' | ');
  }
  
  switch (schema.type) {
    case 'string':
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      if (schema.items) {
        return `Array<${convertSchemaToTypeScript(schema.items, depth + 1)}>`;
      }
      return 'Array<any>';
    case 'object':
      if (schema.properties) {
        const props: string[] = [];
        for (const [propName, propSchema] of Object.entries(schema.properties)) {
          const isRequired = schema.required?.includes(propName) ?? false;
          const propType = convertSchemaToTypeScript(propSchema, depth + 1);
          props.push(`  ${propName}${isRequired ? '' : '?'}: ${propType};`);
        }
        return `{\n${props.join('\n')}\n}`;
      }
      if (schema.additionalProperties) {
        if (typeof schema.additionalProperties === 'boolean') {
          return 'Record<string, any>';
        }
        return `Record<string, ${convertSchemaToTypeScript(schema.additionalProperties, depth + 1)}>`;
      }
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

function generateRequestType(operationId: string, operation: any): string | null {
  const parts: string[] = [];
  
  // Parameters
  if (operation.parameters) {
    const queryParams: string[] = [];
    const pathParams: string[] = [];
    const headerParams: string[] = [];
    
    for (const param of operation.parameters) {
      const paramType = param.schema ? convertSchemaToTypeScript(param.schema) : 'string';
      const isRequired = param.required ?? false;
      const propDef = `${param.name}${isRequired ? '' : '?'}: ${paramType}`;
      
      switch (param.in) {
        case 'query':
          queryParams.push(`    ${propDef};`);
          break;
        case 'path':
          pathParams.push(`    ${propDef};`);
          break;
        case 'header':
          headerParams.push(`    ${propDef};`);
          break;
      }
    }
    
    if (queryParams.length > 0) {
      parts.push(`  query?: {\n${queryParams.join('\n')}\n  };`);
    }
    if (pathParams.length > 0) {
      parts.push(`  params: {\n${pathParams.join('\n')}\n  };`);
    }
    if (headerParams.length > 0) {
      parts.push(`  headers?: {\n${headerParams.join('\n')}\n  };`);
    }
  }
  
  // Request body
  if (operation.requestBody) {
    const content = operation.requestBody.content;
    if (content && content['application/json']?.schema) {
      const bodyType = convertSchemaToTypeScript(content['application/json'].schema);
      parts.push(`  body: ${bodyType};`);
    }
  }
  
  if (parts.length === 0) return null;
  
  return `export interface ${sanitizeTypeName(operationId)}Request {\n${parts.join('\n')}\n}`;
}

function generateResponseTypes(operationId: string, operation: any): string[] {
  const types: string[] = [];
  
  if (operation.responses) {
    for (const [statusCode, response] of Object.entries(operation.responses)) {
      if (!response || typeof response !== 'object') continue;
      
      const content = (response as any).content;
      if (content && content['application/json']?.schema) {
        const responseType = convertSchemaToTypeScript(content['application/json'].schema);
        const typeName = `${sanitizeTypeName(operationId)}Response${statusCode === 'default' ? '' : statusCode}`;
        types.push(`export type ${typeName} = ${responseType};`);
      }
    }
  }
  
  return types;
}

function sanitizeTypeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^(\d)/, '_$1')
    .split('_')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function sanitizeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^(\d)/, '_$1');
}

function extractRefName(ref: string): string {
  const parts = ref.split('/');
  return sanitizeTypeName(parts[parts.length - 1]);
}