import { OpenAPISpec, GeneratedFile, Config } from '../config/types';

/**
 * Generate Cloudflare Workers-compatible API client stubs
 */
export function generateStubs(spec: OpenAPISpec, config: Config): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  
  // Generate main API client
  const clientCode = generateApiClient(spec, config);
  files.push(clientCode);
  
  // Generate individual worker files for each route group if generating Cloudflare Worker
  if (config.generateCloudflareWorker) {
    const workerFiles = generateRouteWorkers(spec, config);
    files.push(...workerFiles);
    
    // Generate main router worker
    const mainWorker = generateCloudflareWorker(spec, config);
    files.push(mainWorker);
  }
  
  return files;
}

function generateRouteWorkers(spec: OpenAPISpec, config: Config): GeneratedFile[] {
  const routeGroups = groupRoutesByPrefix(spec);
  const workerFiles: GeneratedFile[] = [];
  
  for (const [routePrefix, routes] of Object.entries(routeGroups)) {
    const workerFile = generateRouteWorker(routePrefix, routes, spec, config);
    workerFiles.push(workerFile);
  }
  
  return workerFiles;
}

function groupRoutesByPrefix(spec: OpenAPISpec): Record<string, Array<{ path: string; pathItem: any }>> {
  const groups: Record<string, Array<{ path: string; pathItem: any }>> = {};
  
  if (!spec.paths) return groups;
  
  for (const [path, pathItem] of Object.entries(spec.paths)) {
    if (!pathItem) continue;
    
    // Extract the first path segment as the route prefix
    const segments = path.split('/').filter(Boolean);
    const routePrefix = segments[0] || 'root';
    
    if (!groups[routePrefix]) {
      groups[routePrefix] = [];
    }
    
    groups[routePrefix].push({ path, pathItem });
  }
  
  return groups;
}

function generateRouteWorker(routePrefix: string, routes: Array<{ path: string; pathItem: any }>, spec: OpenAPISpec, config: Config): GeneratedFile {
  const lines: string[] = [];
  
  lines.push(`// Generated ${routePrefix} worker from OpenAPI specification`);
  lines.push('// Do not edit this file manually');
  lines.push('');
  lines.push('import { } from "./types";');
  lines.push('import { ApiClient } from "./api-client";');
  lines.push('');
  
  // Environment interface
  lines.push('interface Env {');
  lines.push('  API_KEY?: string;');
  lines.push('  API_BASE_URL?: string;');
  lines.push('}');
  lines.push('');
  
  // Worker export
  lines.push('export default {');
  lines.push('  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {');
  lines.push('    const url = new URL(request.url);');
  lines.push('    const path = url.pathname;');
  lines.push('    const method = request.method.toUpperCase();');
  lines.push('');
  
  lines.push('    // Initialize API client with environment variables');
  lines.push('    const apiClient = new ApiClient({');
  lines.push('      baseUrl: env.API_BASE_URL,');
  lines.push('      apiKey: env.API_KEY,');
  lines.push('    });');
  lines.push('');
  
  lines.push('    try {');
  lines.push('      // Route based on method and path');
  lines.push('      switch (method) {');
  
  // Group operations by HTTP method
  const methodGroups = groupOperationsByMethod(routes);
  
  for (const [method, operations] of Object.entries(methodGroups)) {
    if (operations.length === 0) continue;
    
    lines.push(`        case "${method.toUpperCase()}":`);
    lines.push('          return await this.handle' + capitalize(method.toLowerCase()) + '(request, path, url, env);');
  }
  
  lines.push('        default:');
  lines.push('          return new Response("Method Not Allowed", { status: 405 });');
  lines.push('      }');
  lines.push('    } catch (error: any) {');
  lines.push(`      console.error("${routePrefix} worker error:", error);`);
  lines.push('      return new Response(');
  lines.push('        JSON.stringify({ error: error.message }),');
  lines.push('        {');
  lines.push('          status: 500,');
  lines.push('          headers: { "Content-Type": "application/json" },');
  lines.push('        }');
  lines.push('      );');
  lines.push('    }');
  lines.push('  },');
  lines.push('');
  
  // Generate method handlers
  for (const [method, operations] of Object.entries(methodGroups)) {
    if (operations.length === 0) continue;
    
    const methodHandler = generateMethodHandler(method, operations);
    lines.push(methodHandler);
    lines.push('');
  }
  
  lines.push('};');

  return {
    path: `${routePrefix}_worker.ts`,
    content: lines.join('\n'),
    description: `Generated ${routePrefix} route worker`
  };
}

function groupOperationsByMethod(routes: Array<{ path: string; pathItem: any }>): Record<string, Array<{ path: string; operation: any; operationId: string }>> {
  const groups: Record<string, Array<{ path: string; operation: any; operationId: string }>> = {
    get: [],
    post: [],
    put: [],
    delete: [],
    patch: [],
    options: [],
    head: []
  };
  
  for (const { path, pathItem } of routes) {
    const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];
    
    for (const method of methods) {
      const operation = pathItem[method];
      if (operation) {
        const operationId = operation.operationId || `${method}${sanitizeName(path)}`;
        groups[method].push({ path, operation, operationId });
      }
    }
  }
  
  return groups;
}

function generateMethodHandler(method: string, operations: Array<{ path: string; operation: any; operationId: string }>): string {
  const lines: string[] = [];
  const methodName = 'handle' + capitalize(method.toLowerCase());
  
  lines.push(`  async ${methodName}(request: Request, path: string, url: URL, env: any): Promise<Response> {`);
  
  if (operations.length === 1) {
    // Single operation - no need for additional switch
    const { path: opPath, operation, operationId } = operations[0];
    const handler = generateSingleOperationHandler(opPath, operation, operationId);
    lines.push(handler);
  } else {
    // Multiple operations - switch on path patterns
    lines.push('    // Route based on path pattern');
    
    for (const { path: opPath, operation, operationId } of operations) {
      const pathPattern = opPath.replace(/{([^}]+)}/g, '([^/]+)');
      const pathRegex = `^${pathPattern}$`;
      
      lines.push(`    if (path.match(/${pathRegex}/)) {`);
      const handler = generateSingleOperationHandler(opPath, operation, operationId, '      ');
      lines.push(handler);
      lines.push('    }');
      lines.push('');
    }
    
    lines.push('    return new Response("Not Found", { status: 404 });');
  }
  
  lines.push('  }');
  
  return lines.join('\n');
}

function generateSingleOperationHandler(path: string, operation: any, operationId: string, indent: string = '    '): string {
  const lines: string[] = [];
  
  // Extract path parameters
  const pathParams = [...path.matchAll(/{([^}]+)}/g)].map(match => match[1]);
  if (pathParams.length > 0) {
    const pathPattern = path.replace(/{([^}]+)}/g, '([^/]+)');
    const pathRegex = `^${pathPattern}$`;
    lines.push(`${indent}const pathMatch = path.match(/${pathRegex}/);`);
    pathParams.forEach((param, index) => {
      lines.push(`${indent}const ${param} = pathMatch?.[${index + 1}];`);
    });
  }
  
  // Parse query parameters
  lines.push(`${indent}const query = Object.fromEntries(url.searchParams.entries());`);
  
  // Parse request body if needed (for non-GET/DELETE methods)
  if (!['get', 'delete', 'head', 'options'].includes(operation.method?.toLowerCase() || '')) {
    lines.push(`${indent}const body = await request.json().catch(() => ({}));`);
  }
  
  // Generate stub response
  lines.push(`${indent}`);
  lines.push(`${indent}// TODO: Implement ${operationId} business logic`);
  lines.push(`${indent}// Operation: ${operation.summary || 'No summary provided'}`);
  if (operation.description) {
    lines.push(`${indent}// Description: ${operation.description}`);
  }
  lines.push(`${indent}`);
  
  lines.push(`${indent}const result = {`);
  lines.push(`${indent}  message: "Stub response for ${operationId}",`);
  lines.push(`${indent}  operationId: "${operationId}",`);
  lines.push(`${indent}  path: "${path}",`);
  if (pathParams.length > 0) {
    lines.push(`${indent}  pathParams: {`);
    pathParams.forEach(param => {
      lines.push(`${indent}    ${param},`);
    });
    lines.push(`${indent}  },`);
  }
  lines.push(`${indent}  query,`);
  if (!['get', 'delete', 'head', 'options'].includes(operation.method?.toLowerCase() || '')) {
    lines.push(`${indent}  body,`);
  }
  lines.push(`${indent}};`);
  lines.push(`${indent}`);
  lines.push(`${indent}return new Response(JSON.stringify(result), {`);
  lines.push(`${indent}  headers: { "Content-Type": "application/json" },`);
  lines.push(`${indent}});`);
  
  return lines.join('\n');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function generateApiClient(spec: OpenAPISpec, config: Config): GeneratedFile {
  const operations: string[] = [];
  
  // Add file header
  operations.push('// Generated API client from OpenAPI specification');
  operations.push('// Compatible with Cloudflare Workers');
  operations.push('// Do not edit this file manually');
  operations.push('');
  operations.push('import { } from "./types";');
  operations.push('');
  
  // Generate base client class
  operations.push('export interface ApiConfig {');
  operations.push('  baseUrl?: string;');
  operations.push('  apiKey?: string;');
  operations.push('  headers?: Record<string, string>;');
  operations.push('}');
  operations.push('');
  
  operations.push('export class ApiClient {');
  operations.push('  private baseUrl: string;');
  operations.push('  private defaultHeaders: Record<string, string>;');
  operations.push('');
  operations.push('  constructor(config: ApiConfig = {}) {');
  operations.push(`    this.baseUrl = config.baseUrl || '${spec.servers?.[0]?.url || 'https://api.example.com'}';`);
  operations.push('    this.defaultHeaders = {');
  operations.push('      "Content-Type": "application/json",');
  operations.push('      ...config.headers,');
  operations.push('    };');
  operations.push('    if (config.apiKey) {');
  operations.push('      this.defaultHeaders.Authorization = `Bearer ${config.apiKey}`;');
  operations.push('    }');
  operations.push('  }');
  operations.push('');
  
  // Generate operation methods
  if (spec.paths) {
    for (const [path, pathItem] of Object.entries(spec.paths)) {
      if (!pathItem) continue;
      
      const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];
      
      for (const method of methods) {
        const operation = pathItem[method as keyof typeof pathItem];
        if (!operation) continue;
        
        const methodCode = generateOperationMethod(path, method, operation, spec);
        operations.push(methodCode);
        operations.push('');
      }
    }
  }
  
  operations.push('}');
  operations.push('');
  operations.push('// Export a default instance');
  operations.push('export const api = new ApiClient();');

  return {
    path: 'api-client.ts',
    content: operations.join('\n'),
    description: 'Generated API client for Cloudflare Workers'
  };
}

function generateOperationMethod(path: string, method: string, operation: any, spec: OpenAPISpec): string {
  const operationId = operation.operationId || `${method}${sanitizeName(path)}`;
  const methodName = camelCase(operationId);
  
  // Generate method signature
  const params: string[] = [];
  const pathParams: string[] = [];
  const queryParams: string[] = [];
  let hasBody = false;
  
  // Process parameters
  if (operation.parameters) {
    for (const param of operation.parameters) {
      switch (param.in) {
        case 'path':
          pathParams.push(param.name);
          params.push(`${param.name}: string`);
          break;
        case 'query':
          queryParams.push(param.name);
          break;
        case 'header':
          // Headers handled separately
          break;
      }
    }
  }
  
  // Add query params as optional object
  if (queryParams.length > 0) {
    params.push('query?: Record<string, any>');
  }
  
  // Add body parameter if request body exists
  if (operation.requestBody) {
    hasBody = true;
    params.push('body?: any');
  }
  
  // Add options parameter
  params.push('options?: RequestInit');
  
  const signature = `  async ${methodName}(${params.join(', ')}): Promise<Response>`;
  
  // Generate method body
  const lines: string[] = [];
  lines.push(`${signature} {`);
  
  // Build URL
  let urlBuilder = `\`\${this.baseUrl}${path}\``;
  for (const pathParam of pathParams) {
    urlBuilder = urlBuilder.replace(`{${pathParam}}`, `\${${pathParam}}`);
  }
  
  lines.push(`    let url = ${urlBuilder};`);
  
  // Add query parameters
  if (queryParams.length > 0) {
    lines.push('    if (query) {');
    lines.push('      const params = new URLSearchParams(query);');
    lines.push('      url += `?${params.toString()}`;');
    lines.push('    }');
  }
  
  // Build request options
  lines.push('');
  lines.push('    const requestOptions: RequestInit = {');
  lines.push(`      method: '${method.toUpperCase()}',`);
  lines.push('      headers: {');
  lines.push('        ...this.defaultHeaders,');
  lines.push('        ...options?.headers,');
  lines.push('      },');
  
  if (hasBody) {
    lines.push('      body: body ? JSON.stringify(body) : undefined,');
  }
  
  lines.push('      ...options,');
  lines.push('    };');
  lines.push('');
  
  // Make the request
  lines.push('    const response = await fetch(url, requestOptions);');
  lines.push('');
  
  // Add basic error handling
  lines.push('    if (!response.ok) {');
  lines.push('      throw new Error(`HTTP error! status: ${response.status}`);');
  lines.push('    }');
  lines.push('');
  lines.push('    return response;');
  lines.push('  }');
  
  return lines.join('\n');
}

function generateCloudflareWorker(spec: OpenAPISpec, config: Config): GeneratedFile {
  // Group routes by their base path (first segment)
  const routeGroups = groupRoutesByPrefix(spec);
  
  const lines: string[] = [];
  
  lines.push('// Generated main Cloudflare Worker router from OpenAPI specification');
  lines.push('// Do not edit this file manually');
  lines.push('');
  
  // Import all the route-specific workers
  Object.keys(routeGroups).forEach(routePrefix => {
    const workerName = `${sanitizeName(routePrefix)}Worker`;
    lines.push(`import ${workerName} from "./${routePrefix}_worker";`);
  });
  
  lines.push('');
  
  // Environment interface
  lines.push('interface Env {');
  lines.push('  API_KEY?: string;');
  lines.push('  API_BASE_URL?: string;');
  lines.push('}');
  lines.push('');
  
  // Main worker export with simple routing
  lines.push('export default {');
  lines.push('  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {');
  lines.push('    const url = new URL(request.url);');
  lines.push('    const pathSegments = url.pathname.split("/").filter(Boolean);');
  lines.push('    const routePrefix = pathSegments[0] || "root";');
  lines.push('');
  
  lines.push('    try {');
  lines.push('      // Route to appropriate worker based on path prefix');
  lines.push('      switch (routePrefix) {');
  
  Object.keys(routeGroups).forEach(routePrefix => {
    const workerName = `${sanitizeName(routePrefix)}Worker`;
    lines.push(`        case "${routePrefix}":`);
    lines.push(`          return await ${workerName}.fetch(request, env, ctx);`);
  });
  
  lines.push('        default:');
  lines.push('          return new Response("Not Found", { status: 404 });');
  lines.push('      }');
  lines.push('    } catch (error: any) {');
  lines.push('      console.error("Router error:", error);');
  lines.push('      return new Response(');
  lines.push('        JSON.stringify({ error: error.message }),');
  lines.push('        {');
  lines.push('          status: 500,');
  lines.push('          headers: { "Content-Type": "application/json" },');
  lines.push('        }');
  lines.push('      );');
  lines.push('    }');
  lines.push('  },');
  lines.push('};');

  return {
    path: 'worker.ts',
    content: lines.join('\n'),
    description: 'Generated main Cloudflare Worker router'
  };
}

function sanitizeName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/^(\d)/, '_$1');
}

function camelCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, '_')
    .split('_')
    .map((word, index) => {
      if (index === 0) return word.toLowerCase();
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join('');
}